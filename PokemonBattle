import java.util.Scanner;
import java.util.Random;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;

public class App {

 // --- GAME-WIDE CONSTANTS AND COUNTERS ---
 private static int p1HealthPotionsRemaining = 3; // Max 3
 private static int p1ManaPotionsRemaining = 5;   // Max 5
 private static int p2HealthPotionsRemaining = 3;
 private static int p2ManaPotionsRemaining = 5;
 
 // Helper Class/Data Structures (Kept minimal, using simple fields)
 private static class SkillData {
  final String skillName;
  final int baseDamage;
  final int staminaCost;
  final String targetStatus;
  final int accuracy;

  SkillData(String name, int dmg, int cost, String status, int acc) {
   this.skillName = name;
   this.baseDamage = dmg;
   this.staminaCost = cost;
   this.targetStatus = status;
   this.accuracy = acc;
  }
 }
 
 private static class InitialStats {
     final int maxHealth;
     final int maxStamina;
     
     InitialStats(int maxHp, int maxStam) {
         this.maxHealth = maxHp;
         this.maxStamina = maxStam;
     }
 }


 /**
  * Pokemon class containing all game logic for attacks, status effects, and stats.
  */
 static class Pokemon {
  String name;
  String originalName;
  int health;
  int stamina;
  final int maxHealth;
  final int maxStamina;
  String type;
  String status;
  int duration;
  int skill4UsedCount;
  boolean isMegaEvolved;
  double damageMultiplier = 1.0;
  boolean isFainted = false;
  boolean lastActionWasProtect = false; 

  private final Random random = new Random();

  // --- DATA ARRAYS ---
  private static final String[] POKEMON_NAMES = {"Charizard", "Blastoise", "Venusaur", "Pikachu", "Tyranitar", "Salamence", "Snorlax", "Sylveon", "Garchomp"};
  private static final String[] POKEMON_TYPES = {"Fire", "Water", "Grass", "Electric", "Dark", "Dragon", "Normal", "Fairy", "Ground"};
  private static final String[] MEGA_EVO_NAMES = {"Mega Charizard", "Mega Blastoise", "Mega Venusaur", "Mega Raichu", "Mega Tyranitar", "Mega Salamence", "Snorlax", "Mega Sylveon", "Mega Garchomp"};

  /**
   * Defines the specific HP and Stamina values for each Pokemon.
   */
  private static InitialStats getInitialStats(String name) {
      if (name.equals("Charizard") || name.equals("Blastoise") || name.equals("Venusaur")) {
          return new InitialStats(300, 150);
      } else if (name.equals("Pikachu")) {
          return new InitialStats(250, 200);
      } else if (name.equals("Tyranitar") || name.equals("Salamence")) {
          return new InitialStats(350, 120);
      } 
      // NEW POKEMON STATS
      else if (name.equals("Snorlax")) {
          return new InitialStats(400, 100);
      } else if (name.equals("Sylveon")) {
          return new InitialStats(280, 170);
      } else if (name.equals("Garchomp")) {
          return new InitialStats(300, 150);
      }
      return new InitialStats(120, 120); // Default fallback
  }

  Pokemon(String name, String type, String status) {
   this.originalName = name;
   this.name = name;
   
   InitialStats stats = getInitialStats(name);
   this.maxHealth = stats.maxHealth;
   this.maxStamina = stats.maxStamina;
   
   this.health = this.maxHealth;
   this.stamina = this.maxStamina;
   this.type = type;
   this.status = status;
   this.duration = 0;
   this.skill4UsedCount = 0;
   this.isMegaEvolved = false;
   System.out.println(this.name + " is captured!");
  }

  /**
   * Defines skill data for all Pok√©mon. (Private helper method)
   */
  private SkillData getSkillData(int skillNum) {
   String baseName = this.originalName;
   
   if (baseName.equals("Charizard")) {
    if (skillNum == 1) return new SkillData("Flame Thrower", 30, 40, null, 100);
    if (skillNum == 2) return new SkillData("Fire Spin", 30, 50, null, 100);
    if (skillNum == 3) return new SkillData("Fire Fang", 50, 60, "burned", 100);
    if (skillNum == 4) return new SkillData("Fire Blast", 70, 70, null, 50);
   } else if (baseName.equals("Blastoise")) {
    if (skillNum == 1) return new SkillData("Water Gun", 25, 40, null, 100);
    if (skillNum == 2) return new SkillData("Water Pulse", 30, 50, null, 100);
    if (skillNum == 3) return new SkillData("Bubble Beam", 50, 60, "chilled", 100);
    if (skillNum == 4) return new SkillData("Aqua Jet", 70, 70, null, 50);
   } else if (baseName.equals("Venusaur")) {
    if (skillNum == 1) return new SkillData("Vine Whip", 25, 40, null, 100);
    if (skillNum == 2) return new SkillData("Razor Leaf", 30, 50, null, 100);
    if (skillNum == 3) return new SkillData("Seed Bomb", 50, 60, "poisoned", 100);
    if (skillNum == 4) return new SkillData("Solar Beam", 70, 70, null, 50);
   } else if (baseName.equals("Pikachu")) {
    if (skillNum == 1) return new SkillData("Thunder Shock", 30, 40, null, 100);
    if (skillNum == 2) return new SkillData("Electro Ball", 30, 50, null, 100);
    if (skillNum == 3) return new SkillData("Thunder Wave", 50, 60, "paralyzed", 100);
    if (skillNum == 4) return new SkillData("Volt Tackle", 70, 70, null, 50);
   } else if (baseName.equals("Tyranitar")) {
    if (skillNum == 1) return new SkillData("Bite", 30, 40, null, 100);
    if (skillNum == 2) return new SkillData("Crunch", 30, 50, null, 100);
    if (skillNum == 3) return new SkillData("Dark Pulse", 50, 60, "blind", 100);
    if (skillNum == 4) return new SkillData("Hyper Beam", 70, 70, null, 50);
   } else if (baseName.equals("Salamence")) {
    if (skillNum == 1) return new SkillData("Dragon Breath", 30, 40, null, 100);
    if (skillNum == 2) return new SkillData("Dragon Claw", 30, 50, null, 100);
    if (skillNum == 3) return new SkillData("Outrage", 50, 60, "burned", 100);
    if (skillNum == 4) return new SkillData("Draco Meteor", 70, 70, null, 50);
   }
   else if (baseName.equals("Snorlax")) {
    if (skillNum == 1) return new SkillData("Body Slam", 35, 40, null, 100);
    if (skillNum == 2) return new SkillData("Rest", 0, 50, "sleep", 100); // Healing/Status Skill
    if (skillNum == 3) return new SkillData("Heavy Slam", 50, 60, null, 100);
    if (skillNum == 4) return new SkillData("Giga Impact", 80, 70, null, 50);
   } else if (baseName.equals("Sylveon")) {
    if (skillNum == 1) return new SkillData("Fairy Wind", 30, 40, null, 100);
    if (skillNum == 2) return new SkillData("Draining Kiss", 30, 50, null, 100);
    if (skillNum == 3) return new SkillData("Moonblast", 50, 60, null, 100);
    if (skillNum == 4) return new SkillData("Pixie Dust", 70, 70, null, 50);
   } else if (baseName.equals("Garchomp")) {
    if (skillNum == 1) return new SkillData("Bulldoze", 30, 40, null, 100);
    if (skillNum == 2) return new SkillData("Dragon Rush", 30, 50, null, 100);
    if (skillNum == 3) return new SkillData("Earthquake", 60, 60, null, 100);
    if (skillNum == 4) return new SkillData("Draco Meteor", 70, 70, null, 50);
   }
   return null; // Should not happen
  }
  
  /** * Public method to get a skill's name for display in the menu.
   * This is the required method for the App class to call.
   */
  public String getSkillName(int skillNum) {
      SkillData data = getSkillData(skillNum);
      return data != null ? data.skillName : "Unknown Skill";
  }

  /**
   * Replaces TYPE_MODIFIER lookup using if-else blocks.
   */
  private int getTypeModifier(String targetType) {
   String typeCombo = this.type + targetType;
   int modifier = 0;
   
   // --- SUPER EFFECTIVE ATTACKS (+15 Damage) ---
   
   // Existing
   if (typeCombo.equals("FireGrass") || typeCombo.equals("WaterFire") || typeCombo.equals("GrassWater") ||
    typeCombo.equals("ElectricWater") || typeCombo.equals("DarkGrass") || typeCombo.equals("DragonDragon")) {
    modifier = 15; 
   }
   
   // NEW: Sylveon (Fairy) super effective against Dark
   else if (typeCombo.equals("FairyDark")) {
       modifier = 15;
   }
   // NEW: Garchomp (Ground) super effective against Electric, Fire
   else if (typeCombo.equals("GroundElectric") || typeCombo.equals("GroundFire")) {
       modifier = 15;
   }
   
   // --- NOT VERY EFFECTIVE / RESISTED ATTACKS (-15 Damage) ---
   
   // Existing
   else if (typeCombo.equals("FireWater") || typeCombo.equals("WaterGrass") ||
    typeCombo.equals("ElectricGrass") || typeCombo.equals("DarkFire") || typeCombo.equals("DarkWater") ||
    typeCombo.equals("DragonFire") || typeCombo.equals("DragonWater")) {
    modifier = -15; 
   }
   
   // NEW: Sylveon (Fairy) resists Dark
   else if (this.type.equals("Dark") && targetType.equals("Fairy")) {
       modifier = -15;
   } 
   // NEW: Sylveon (Fairy) weak against Fire
   else if (this.type.equals("Fire") && targetType.equals("Fairy")) {
       modifier = 15; // Fire is Super Effective against Fairy
   }
   // NEW: Garchomp (Ground) resists Electric
   else if (this.type.equals("Electric") && targetType.equals("Ground")) {
       modifier = -15; 
   }
   // NEW: Garchomp (Ground) weak against Water, Grass, Fairy
   else if ((this.type.equals("Water") || this.type.equals("Grass") || this.type.equals("Fairy")) && targetType.equals("Ground")) {
       modifier = 15; // Water/Grass/Fairy are Super Effective against Ground
   }
   // NEW: Snorlax (Normal) has no modifiers against any existing type, so no entry needed for Normal attack/defense.

   return modifier;
  }

  /** Handles damage-over-time and decay checks for target's status before attack. */
  private int applyPreAttackStatusEffects(Pokemon target) {
   int damageAdjustment = 0;

   // Handle self-status decay (e.g., Chill duration)
   if (this.duration >= 3 && this.status.equals("chilled")) {
    this.status = "normal"; this.duration = 0;
    System.out.println(this.name + " is now in normal state (Chill wore off).");
   }
   if (this.status.equals("chilled")) {
    System.out.println(this.name + " is chilled! Damage is reduced this turn.");
    this.duration += 1;
    damageAdjustment -= 10;
   }

   // Apply DoT to target
   int statusDamage = 0;
   if (target.status.equals("poisoned") || target.status.equals("burned")) {
    statusDamage = 10;
    System.out.printf("The %s weakens %s! Extra damage dealt.%n", target.status, target.name);
    target.duration += 1;
    if (target.duration > 3) {
     System.out.printf("%s is no longer %s.%n", target.name, target.status);
     target.status = "normal"; target.duration = 0;
    }
   }

   if (!target.status.equals("protected")) {
    target.health -= statusDamage;
   }

   return damageAdjustment;
  }

  private void applyPostAttackLogic(Pokemon target, int staminaCost) {
   this.stamina -= staminaCost;
   if (target.health < 0) target.health = 0;
   System.out.printf("%s's current health is at [%d] points.%n", target.name, target.health);
   System.out.printf("%s lost %d stamina points.%n", this.name, staminaCost);
   if (target.health <= 0) {
    target.isFainted = true;
    System.out.println(target.name + " fainted!");
   }
  }

  // --- TACKLE IMPLEMENTATION ---
  void tackle(Pokemon target) {
      this.lastActionWasProtect = false; // Reset Protect flag on non-Protect action
      
      if (this.status.equals("paralyzed")) {
        System.out.printf("%s is paralyzed and cannot move!%n", this.name);
        return;
      }
      if (target.isFainted) {
        System.out.println(target.name + " has already fainted. Tackle skill failed.");
        return;
      }
      
      int preAttackDamageAdjustment = applyPreAttackStatusEffects(target);
      
      // STAMINA GAIN LOGIC
      int staminaGained = 20;
      int oldStamina = this.stamina;
      this.stamina += staminaGained;
      if (this.stamina > this.maxStamina) {
          this.stamina = this.maxStamina;
      }
      int actualGain = this.stamina - oldStamina;
      
      if (actualGain > 0) {
          System.out.println(this.name + " recovered " + actualGain + " stamina points.");
      } else {
          System.out.println(this.name + " has full stamina (" + this.maxStamina + "/" + this.maxStamina + "), no stamina gained.");
      }
      
      // DAMAGE LOGIC
      int baseDamage = (this.originalName.equals("Pikachu")) ? 30 : 40; // Pikachu is 30, others are 40
      
      if (this.status.equals("protected")) {
          System.out.printf("%s is protected and cannot launch an attack this turn!%n", this.name);
          return;
      }
      
      if (target.status.equals("protected")) {
          System.out.printf("%s is protected! No damage taken this turn.%n", target.name);
          return;
      }
      
      System.out.printf("%s used Tackle on %s.%n", this.name, target.name);
      
      int finalDamage = baseDamage + preAttackDamageAdjustment;
      finalDamage = (int) (finalDamage * this.damageMultiplier);
      
      if (this.isMegaEvolved) {
        System.out.printf("Mega Evolve bonus applied! Total Damage: %d%n", finalDamage);
      }
      
      target.health -= finalDamage;
      
      // Check for fainted (No stamina cost to deduct)
      if (target.health < 0) target.health = 0;
      System.out.printf("%s's current health is at [%d] points.%n", target.name, target.health);
      
      if (target.health <= 0) {
        target.isFainted = true;
        System.out.println(target.name + " fainted!");
      }
  }
  // --- END TACKLE IMPLEMENTATION ---

  private boolean executeSkillAttack(Pokemon target, int skillNum) { // <-- CHANGED TO BOOLEAN
   SkillData data = getSkillData(skillNum);
   
   this.lastActionWasProtect = false; // <<< Reset Protect flag on non-Protect action

   if (this.status.equals("paralyzed")) {
    System.out.printf("%s is paralyzed and cannot move!%n", this.name);
    return true; // Turn is consumed by status effect
   }
   if (this.status.equals("protected")) {
    System.out.printf("%s is protected and cannot launch an attack this turn!%n", this.name);
    return true; // Turn is consumed by Protect status
   }
   if (target.isFainted) {
    System.out.printf("%s has already fainted. Skill %d failed.%n", target.name, skillNum);
    return false; // Action failed, return to menu
   }

   int preAttackDamageAdjustment = applyPreAttackStatusEffects(target);

   if (this.stamina < data.staminaCost) {
    System.out.printf("%s doesn't have enough stamina (%d/%d) to use %s! Choose another action.%n",
     this.name, this.stamina, data.staminaCost, data.skillName);
    return false; // <-- CRITICAL FIX: Signal failure, do not end turn
   }
   
   // Handle Snorlax Rest healing (Skill 2)
   if (this.originalName.equals("Snorlax") && skillNum == 2) {
       this.health += 100; 
       this.health = Math.min(this.health, this.maxHealth);
       this.stamina -= data.staminaCost;
       this.status = "sleep"; 
       this.duration = 1; 
       System.out.printf("%s used Rest! Health restored. Current HP: %d/%d. %s is now sleeping (3 turns).%n", 
           this.name, this.health, this.maxHealth, this.name);
       return true; // Action successful
   }

   if (skillNum == 4 && !this.isMegaEvolved) {
    this.skill4UsedCount++;
    System.out.printf("(Skill 4 used: %d/3)%n", this.skill4UsedCount);
   }

   int effectiveAccuracy = data.accuracy;
   if (this.status.equals("blind") || this.status.equals("sleep")) { 
    if (this.status.equals("sleep")) {
        System.out.printf("%s is asleep and cannot move!%n", this.name);
        return true; // Turn is consumed by status effect
    }
    effectiveAccuracy = 35;
    System.out.printf("%s is blind! Attack accuracy fixed at 35%%.%n", this.name);
   }

   if (effectiveAccuracy < 100 && random.nextInt(100) >= effectiveAccuracy) {
    System.out.printf("%s's attack missed!%n", this.name);
    this.stamina -= (data.staminaCost / 2);
    System.out.printf("%s lost %d stamina points (half cost).%n", this.name, data.staminaCost / 2);
    return true; // Attack missed but turn is consumed
   }

   if (target.status.equals("protected")) {
    System.out.printf("%s is protected! No damage taken this turn.%n", target.name);
    this.stamina -= data.staminaCost;
    System.out.printf("%s lost %d stamina points.%n", this.name, data.staminaCost);
    return true; // Attack blocked but turn is consumed
   }

   // ... (Rest of the attack logic remains the same) ...
   System.out.printf("%s used %s on %s.%n", this.name, data.skillName, target.name);
   int damage = data.baseDamage + preAttackDamageAdjustment;

   int typeMod = getTypeModifier(target.type);
   damage += typeMod;

   if (typeMod > 0) System.out.println("It's super effective!");
   else if (typeMod < 0) System.out.println("It's not very effective...");

   if ((skillNum == 3 || skillNum == 4) && random.nextInt(100) < 20) {
    int critBonus = (skillNum == 3) ? 25 : 70;
    damage += critBonus;
    System.out.println("A critical hit!");
   }

   damage = (int) (damage * this.damageMultiplier);
   if (this.isMegaEvolved) {
    System.out.printf("Mega Evolve bonus applied! Total Damage: %d%n", damage);
   }

   target.health -= damage;

   if (skillNum == 3 && data.targetStatus != null && random.nextInt(100) < 20) {
    target.status = data.targetStatus;
    target.duration = 1;
    System.out.printf("%s is %s! It will have a status effect for 3 turns.%n", target.name, target.status);
   }

   applyPostAttackLogic(target, data.staminaCost);
   return true; // Action successful
  }

  // Generic potion usage, called by App after checking limits
  void usePotion(String potionType, int amount) {
   this.lastActionWasProtect = false; // <<< Reset Protect flag
   
   int statusDamage = 0;

   // Status effect damage application
   if (this.status.equals("poisoned") || this.status.equals("burned")) {
    statusDamage = 10;
    System.out.printf("%s is %s! Received %d damage while using a potion.%n", this.name, this.status, statusDamage);
    this.duration += 1;
    if (this.duration > 3) {
     this.status = "normal"; this.duration = 0;
     System.out.printf("%s is no longer %s (Status wore off).%n", this.name, this.status);
    }
   }

   if (!this.status.equals("protected")) {
    this.health -= statusDamage;
   }
   
   // Apply heal
   if ("mana".equals(potionType)) {
    this.stamina += amount;
    this.stamina = Math.min(this.stamina, this.maxStamina); 
    System.out.printf("%s used a mana potion and gained %d stamina points. Current: %d%n", this.name, amount, this.stamina);
   } else if ("health".equals(potionType)) {
    this.health += amount;
    this.health = Math.min(this.health, this.maxHealth);
    System.out.printf("%s used a health potion and gained %d health points. Current: %d%n", this.name, amount, this.health);
   }
  }

  void megaEvolve() {
   this.lastActionWasProtect = false; // <<< Reset Protect flag
   final int MEGA_COST = 100;
   final int REQUIRED_SKILL4 = 3;
   final double DAMAGE_BOOST = 1.5;

   if (this.status.equals("paralyzed") || this.status.equals("sleep")) {
    System.out.printf("%s is %s and cannot move!%n", this.name, this.status);
    return;
   }

   if (this.isMegaEvolved) {
    System.out.printf("%s is already Mega Evolved!%n", this.name); return;
   }
   if (this.stamina < MEGA_COST || this.skill4UsedCount < REQUIRED_SKILL4) {
    System.out.printf("%s failed to Mega Evolve. Requires 100 Stamina (Have: %d) and %d Skill 4 uses (Have: %d).%n",
     this.name, this.stamina, REQUIRED_SKILL4, this.skill4UsedCount);
    return;
   }

   this.stamina -= MEGA_COST;
   this.damageMultiplier = DAMAGE_BOOST;
   this.isMegaEvolved = true;

   String megaName = this.originalName;
   for(int i = 0; i < POKEMON_NAMES.length; i++) {
    if(POKEMON_NAMES[i].equals(this.originalName)) {
     megaName = MEGA_EVO_NAMES[i];
     break;
    }
   }

   System.out.printf("‚ö° %s Mega Evolved into %s! Damage boosted by 50%%! ‚ö°%n", this.name, megaName);
   this.name = megaName;
   this.skill4UsedCount = 0;
  }

  // CAVEAT 1 IMPLEMENTATION: Updated Protect logic
  boolean useProtect() { 
   if (this.status.equals("paralyzed") || this.status.equals("sleep")) {
    System.out.printf("%s is %s and cannot move!%n", this.name, this.status);
    return false;
   }
   
   // NEW LOGIC: Cannot use Protect twice in a row
   if (this.lastActionWasProtect) {
    System.out.printf("%s failed to use Protect! It can't be used two turns in a row.%n", this.name);
    return false;
   }
   
   this.status = "protected";
   this.duration = 1; 
   this.lastActionWasProtect = true; 
   System.out.printf("üõ°Ô∏è %s used Protect! It is now shielded from damage this turn only. üõ°Ô∏è%n", this.name);
   return true; 
  }

  boolean skill1(Pokemon target) { return executeSkillAttack(target, 1); }
  boolean skill2(Pokemon target) { return executeSkillAttack(target, 2); }
  boolean skill3(Pokemon target) { return executeSkillAttack(target, 3); }
  boolean skill4(Pokemon target) { return executeSkillAttack(target, 4); }

  void showStats(boolean isPlayer) {
   System.out.println("Name: " + this.name + (this.isFainted ? " (Fainted)" : ""));
   if (this.isFainted) return;

   System.out.println(" Health: " + this.health + "/" + this.maxHealth); 
   System.out.println(" Stamina: " + this.stamina + "/" + this.maxStamina); 
   System.out.println(" Type: " + this.type);

   int remainingTurns = 4 - this.duration;
   String statusInfo;
   if (this.status.equals("protected")) {
       statusInfo = "protected (Shielded this turn)"; 
   } else if (this.duration > 0 && !this.status.equals("normal")) {
    statusInfo = String.format("%s (Remaining Turns: %d)", this.status, remainingTurns);
   } else {
    statusInfo = this.status;
   }
   System.out.println(" Status: " + statusInfo);
   
   if (!this.isFainted && this.lastActionWasProtect && !this.status.equals("protected")) {
       System.out.println(" WARNING: Cannot use Protect next turn!");
   }
   
   System.out.println(" Skill 4 Uses: " + this.skill4UsedCount + "/3");
   System.out.println(" Damage Multiplier: x" + this.damageMultiplier);
   
   if(isPlayer) {
       System.out.printf(" Potions Left - Health: %d/3 | Mana: %d/5%n", p1HealthPotionsRemaining, p1ManaPotionsRemaining);
   } else {
       System.out.printf(" Potions Left - Health: %d/3 | Mana: %d/5%n", p2HealthPotionsRemaining, p2ManaPotionsRemaining);
   }
  }
 }

 // --- Application Logic ---

 private static final List<String> ALL_POKEMON_NAMES = Arrays.asList(Pokemon.POKEMON_NAMES);
 private static final List<String> ALL_POKEMON_TYPES = Arrays.asList(Pokemon.POKEMON_TYPES);

 private static void simulateDelay() throws InterruptedException {
  System.out.print("Loading...");
  Thread.sleep(1000);
  System.out.println(".Done!");
 }

 /** Advances duration for non-DoT status effects (Protected, Paralyzed, Blind, Chilled, Sleep). */
 private static void advanceStatusDuration(Pokemon p) {
  // Always clear Protected status here, as it only lasts one turn.
  if (p.status.equals("protected")) {
   System.out.printf("--- %s's Protect wore off!%n", p.name);
   p.status = "normal";
   p.duration = 0;
  }

  if (!p.status.equals("normal") && !p.status.equals("poisoned") && !p.status.equals("burned")) {
   p.duration++;
   // Sleep duration ends after 3 turns
   if (p.duration > 3) {
    System.out.printf("--- %s's %s wore off!%n", p.name, p.status);
    p.status = "normal";
    p.duration = 0;
   }
  }
 }

 /** Replaces Map lookups and HashSet checks for player team selection. */
 private static List<Pokemon> choosePlayerTeam(Scanner scanner) {
  List<Pokemon> team = new ArrayList<>();
  List<String> chosenNames = new ArrayList<>(); 

  System.out.println("\n--- Choose your team of 3 Pok√©mon (Enter the number) ---");
  for (int i = 0; i < ALL_POKEMON_NAMES.size(); i++) {
   System.out.printf("%d: %s (%s) [HP: %d, Stamina: %d]%n", 
    i + 1, 
    ALL_POKEMON_NAMES.get(i), 
    ALL_POKEMON_TYPES.get(i),
    Pokemon.getInitialStats(ALL_POKEMON_NAMES.get(i)).maxHealth, 
    Pokemon.getInitialStats(ALL_POKEMON_NAMES.get(i)).maxStamina
   );
  }

  while (team.size() < 3) {
   System.out.printf("Select Pok√©mon %d (1-%d): ", team.size() + 1, ALL_POKEMON_NAMES.size());
   if (scanner.hasNextInt()) {
    int choice = scanner.nextInt();
    scanner.nextLine();
    if (choice >= 1 && choice <= ALL_POKEMON_NAMES.size()) {
     String name = ALL_POKEMON_NAMES.get(choice - 1);
     String type = ALL_POKEMON_TYPES.get(choice - 1);

     if (chosenNames.contains(name)) { 
      System.out.println(name + " is already on your team. Choose another.");
     } else {
      team.add(new Pokemon(name, type, "normal")); 
      chosenNames.add(name);
     }
    } else {
     System.out.println("Invalid number. Please choose between 1 and " + ALL_POKEMON_NAMES.size());
    }
   } else {
    scanner.next();
    System.out.println("Invalid input. Please enter a number.");
   }
  }
  return team;
 }

 /** Creates a team of 3 unique, random Pok√©mon not chosen by the player. */
 private static List<Pokemon> createAITeam(List<String> playerNames, Random random) {
  List<Pokemon> team = new ArrayList<>();
  List<String> availableForAI = new ArrayList<>();
  
  for(String name : ALL_POKEMON_NAMES) {
   if (!playerNames.contains(name)) {
    availableForAI.add(name);
   }
  }

  // Shuffle the remaining Pok√©mon and pick the first 3
  for (int i = 0; i < availableForAI.size(); i++) {
   String temp = availableForAI.get(i);
   int swapIndex = random.nextInt(availableForAI.size());
   availableForAI.set(i, availableForAI.get(swapIndex));
   availableForAI.set(swapIndex, temp);
  }

  for (int i = 0; i < 3; i++) {
   String name = availableForAI.get(i);
   String type = "Unknown";
   for(int j=0; j < Pokemon.POKEMON_NAMES.length; j++) {
    if(Pokemon.POKEMON_NAMES[j].equals(name)) {
     type = Pokemon.POKEMON_TYPES[j];
     break;
    }
   }
   team.add(new Pokemon(name, type, "normal"));
  }
  return team;
 }

 /** Finds the first available (not fainted) Pok√©mon in the team. */
 private static Pokemon findNextAvailablePokemon(List<Pokemon> team) {
  for (Pokemon p : team) {
   if (!p.isFainted) {
    return p;
   }
  }
  return null; // All fainted
 }

 /** * Swaps the current active Pokemon with a selected, available team member.
  * @return The newly swapped-in Pokemon, or the original Pokemon if the swap failed (paralyzed/invalid choice).
  */
 private static Pokemon handlePlayerSwap(Scanner scanner, Pokemon currentP1, List<Pokemon> p1Team) {
  if (currentP1.status.equals("paralyzed") || currentP1.status.equals("sleep")) {
   System.out.printf("%s is %s and cannot swap this turn!%n", currentP1.name, currentP1.status);
   return currentP1;
  }
  
  currentP1.lastActionWasProtect = false; // <<< Reset Protect flag on swap

  System.out.println("\n--- Choose Pokemon to Swap In (Type the number) ---");
  int count = 1;
  for (Pokemon p : p1Team) {
   String status = p.isFainted ? "(Fainted)" : (p == currentP1 ? "(Active)" : "");
   System.out.printf("%d: %s (%s) %s [HP: %d/%d]%n", count, p.name, p.type, status, p.health, p.maxHealth);
   count++;
  }

  int swapChoice;
  while (true) {
   System.out.print("Enter choice (1-3): ");
   if (scanner.hasNextInt()) {
    swapChoice = scanner.nextInt();
    scanner.nextLine();
    if (swapChoice >= 1 && swapChoice <= 3) {
     Pokemon newP = p1Team.get(swapChoice - 1);
     if (newP.isFainted) {
      System.out.println("That Pokemon has fainted. Choose another.");
     } else if (newP == currentP1) {
      System.out.println(newP.name + " is already active!");
     } else {
      System.out.printf("P1 withdrew %s and sent out %s!%n", currentP1.name, newP.name);
      return newP; // Return the new Pok√©mon
     }
    } else {
     System.out.println("Invalid choice. Try again.");
    }
   } else {
    scanner.next();
    System.out.println("Invalid input. Try again.");
   }
  }
 }

 private static Pokemon handleAISwap(Pokemon currentP2, List<Pokemon> p2Team, String reason) throws InterruptedException {
  Pokemon nextP2 = findNextAvailablePokemon(p2Team);
  if (nextP2 == null || nextP2 == currentP2) {
   return currentP2;
  }
  
  currentP2.lastActionWasProtect = false; // <<< Reset Protect flag on swap

  System.out.printf("P2 is considering a tactical swap (%s)...%n", reason);
  simulateDelay();

  for (Pokemon p : p2Team) {
   if (!p.isFainted && p != currentP2) {
    System.out.printf("P2 withdrew %s and sent out %s!%n", currentP2.name, p.name);
    return p;
   }
  }
  return currentP2;
 }
 
 /**
  * Handles the secondary menu for attacks.
  * Returns true if an attack was successfully executed, false otherwise.
  */
/**
 * Handles the secondary menu for attacks.
 * Returns true if an attack was successfully executed, false otherwise.
 */
private static boolean handleAttackMenu(Scanner scanner, Pokemon currentP1, Pokemon currentP2) {
    
    // The menu is printed inside the loop so it shows up again if stamina is too low
    while(true) {
        System.out.println("\n--- Attack Menu ---");
        System.out.println(" 1. Tackle");
        System.out.println(" 2. " + currentP1.getSkillName(1));
        System.out.println(" 3. " + currentP1.getSkillName(2));
        System.out.println(" 4. " + currentP1.getSkillName(3));
        System.out.println(" 5. " + currentP1.getSkillName(4));
        System.out.println(" 6. Back");
    
        int attackChoice;
        boolean actionSuccess = false; // Local flag to hold result
        
        System.out.print("Enter choice (0-5): ");
        if (scanner.hasNextInt()) {
            attackChoice = scanner.nextInt();
            scanner.nextLine();
            
            switch (attackChoice) {
                case 1: 
                    // Tackle is void and doesn't consume turn on status failure, we assume success here
                    currentP1.tackle(currentP2); 
                    return true; 
                case 2: 
                    actionSuccess = currentP1.skill1(currentP2); 
                    break;
                case 3: 
                    actionSuccess = currentP1.skill2(currentP2); 
                    break;
                case 4: 
                    actionSuccess = currentP1.skill3(currentP2); 
                    break;
                case 5: 
                    actionSuccess = currentP1.skill4(currentP2); 
                    break;
                case 6: 
                    return false; // Go back to main menu
                default: 
                    System.out.println("Invalid attack choice. Try again.");
                    break;
            }
            
            // CRITICAL FIX: Only return true (ending the player's turn) if the action succeeded.
            if (actionSuccess) {
                return true;
            }
            // If action failed (e.g., low stamina), the loop continues and prints the menu again.
        } else {
            scanner.next();
            System.out.println("Invalid input. Try again.");
        }
    }
 }
 /**
  * Handles the secondary menu for potions.
  * Returns true if a potion was successfully used, false otherwise.
  */
 private static boolean handleBagMenu(Scanner scanner, Pokemon currentP1) {
    System.out.println("\n--- Bag Menu ---");
    System.out.println(" 1. Mana Potion (Remaining: " + p1ManaPotionsRemaining + "/5)");
    System.out.println(" 2. Health Potion (Remaining: " + p1HealthPotionsRemaining + "/3)");
    System.out.println(" 3. Back");
    
    int bagChoice;
    while(true) {
        System.out.print("Enter choice (1-3): ");
        if (scanner.hasNextInt()) {
            bagChoice = scanner.nextInt();
            scanner.nextLine();
            
            switch (bagChoice) {
                case 1: // Mana Potion
                    currentP1.lastActionWasProtect = false; // Reset Protect flag
                    if (currentP1.status.equals("sleep") || currentP1.status.equals("paralyzed")) {
                        System.out.printf("%s is %s and cannot use a potion this turn!%n", currentP1.name, currentP1.status);
                        return false;
                    }
                    if (p1ManaPotionsRemaining <= 0) {
                        System.out.println(currentP1.name + " is out of Mana Potions! Choose another action.");
                        return false; 
                    }
                    currentP1.usePotion("mana", 60);
                    p1ManaPotionsRemaining--;
                    return true;
                    
                case 2: // Health Potion
                    currentP1.lastActionWasProtect = false; // Reset Protect flag
                    if (currentP1.status.equals("sleep") || currentP1.status.equals("paralyzed")) {
                        System.out.printf("%s is %s and cannot use a potion this turn!%n", currentP1.name, currentP1.status);
                        return false;
                    }
                    if (p1HealthPotionsRemaining <= 0) {
                        System.out.println(currentP1.name + " is out of Health Potions! Choose another action.");
                        return false;
                    }
                    currentP1.usePotion("health", 150);
                    p1HealthPotionsRemaining--;
                    return true;
                    
                case 3: return false; // Go back to main menu
                default: System.out.println("Invalid bag choice. Try again.");
            }
        } else {
            scanner.next();
            System.out.println("Invalid input. Try again.");
        }
    }
 }

 /**
  * Handles the player's turn action.
  * @return The new active Pokemon after the turn's action. Returns the original Pokemon if no change or the action failed.
  */
 private static Pokemon performPlayerTurn(Scanner scanner, Pokemon currentP1, Pokemon currentP2, List<Pokemon> p1Team) throws InterruptedException {
    System.out.println("\n--- " + currentP1.name + "'s Turn (P1) ---");
    currentP1.showStats(true);
    currentP2.showStats(false);
    System.out.println("-------------------------------------");

    boolean actionSuccessful = false;
    Pokemon activeP1 = currentP1;

    while (!actionSuccessful) {

        // ADDED: This prints the main menu every loop
        System.out.println("\nChoose action category:");
        System.out.println(" 1. Attack");
        System.out.println(" 2. Bag");
        System.out.println(" 3. Protect (1-turn shield)");
        System.out.println(" 4. Mega Evolve");
        System.out.println(" 5. Swap Pok√©mon");

        System.out.print("Enter choice (1-5): ");

        int choice;
        if (scanner.hasNextInt()) {
            choice = scanner.nextInt();
            scanner.nextLine();

            switch (choice) {

                case 1: // Attack Menu
                    boolean attackSuccess = handleAttackMenu(scanner, activeP1, currentP2);
                    if (!attackSuccess) {
                        // ADDED: Feedback for the player
                        System.out.println("\nReturned to Main Menu...");
                    } else {
                        actionSuccessful = true;
                    }
                    break;

                case 2: // Bag Menu
                    boolean bagSuccess = handleBagMenu(scanner, activeP1);
                    if (!bagSuccess) {
                        // ADDED: Feedback message
                        System.out.println("\nReturned to Main Menu...");
                    } else {
                        actionSuccessful = true;
                    }
                    break;

                case 3: // Protect
                    if (activeP1.useProtect()) {
                        actionSuccessful = true;
                    }
                    break;

                case 4: // Mega Evolve
                    activeP1.lastActionWasProtect = false;
                    activeP1.megaEvolve();
                    if (activeP1.isMegaEvolved) {
                        actionSuccessful = true;
                    }
                    break;

                case 5: // Swap
                    Pokemon nextP = handlePlayerSwap(scanner, activeP1, p1Team);
                    if (nextP != activeP1) {
                        activeP1 = nextP;
                        actionSuccessful = true;
                    }
                    break;

                default:
                    System.out.println("Invalid choice. Try again.");
            }

        } else {
            scanner.next();
            System.out.println("Invalid input. Try again.");
        }
    }

    return activeP1;
}


 private static Pokemon performAITurn(Pokemon currentP2, Pokemon currentP1, List<Pokemon> p2Team, Random random) throws InterruptedException {
  System.out.println("\n" + currentP2.name + "'s Turn (Automatic)!");
  simulateDelay();

  if (currentP2.status.equals("paralyzed") || currentP2.status.equals("sleep")) {
   System.out.printf("%s is %s and cannot move!%n", currentP2.name, currentP2.status);
   simulateDelay();
   return currentP2;
  }

  // Mega Evolve Tactic
  if (!currentP2.isMegaEvolved && currentP2.stamina >= 100 && currentP2.skill4UsedCount == 3) {
   currentP2.lastActionWasProtect = false; // Reset Protect flag
   currentP2.megaEvolve();
   return currentP2; // Turn ends after Mega Evolve
  }
  
  // Tactical Swap (Triggers if HP is 33% or less)
  else if (currentP2.health <= (int)(currentP2.maxHealth * 0.33) && findNextAvailablePokemon(p2Team) != currentP2) {
   // handleAISwap handles the lastActionWasProtect reset internally
   return handleAISwap(currentP2, p2Team, "Critical Health");
  }

  // Potion Use Tactic (Respects limits, triggers if HP is 33% or less)
  else if (currentP2.health <= (int)(currentP2.maxHealth * 0.33) && p2HealthPotionsRemaining > 0) {
   currentP2.lastActionWasProtect = false; // Reset Protect flag
   currentP2.usePotion("health", 150);
   p2HealthPotionsRemaining--;
  } else if (currentP2.stamina <= (int)(currentP2.maxStamina * 0.33) && p2ManaPotionsRemaining > 0) {
   currentP2.lastActionWasProtect = false; // Reset Protect flag
   currentP2.usePotion("mana", 60);
   p2ManaPotionsRemaining--;
  }
  // Protect Tactic (20% chance if health is 40% or less AND not restricted)
  else if (!currentP2.lastActionWasProtect && currentP2.health <= (int)(currentP2.maxHealth * 0.40) && random.nextInt(100) < 20) {
   // useProtect handles the two-turn check internally
   currentP2.useProtect(); 
  }
  // Normal Attack
  else {
   // Snorlax specific strategy: use Rest if low HP and available (Skill 2)
   if (currentP2.originalName.equals("Snorlax") && currentP2.health <= (int)(currentP2.maxHealth * 0.5) && currentP2.stamina >= 50 && !currentP2.status.equals("sleep")) {
       currentP2.skill2(currentP1); // Snorlax's skill 2 is Rest
   }
   // Prioritize Skill 4 if Mega Evolved or required uses are met
   else if (currentP2.isMegaEvolved || currentP2.skill4UsedCount < 3 && currentP2.stamina >= 70) {
    currentP2.skill4(currentP1);
   } else if (currentP2.stamina >= 60) {
    currentP2.skill3(currentP1);
   } else if (currentP2.stamina >= 50) {
    currentP2.skill2(currentP1);
   } else if (currentP2.stamina >= 40) {
    currentP2.skill1(currentP1);
   } else if (currentP2.stamina < 40) { // If Stamina is low, use Tackle for recovery
    currentP2.tackle(currentP1); // <<< AI uses Tackle
   } else {
    // If no stamina and no mana potions, skip turn
    if (p2ManaPotionsRemaining > 0) {
     currentP2.lastActionWasProtect = false; // Reset Protect flag
     currentP2.usePotion("mana", 50);
     p2ManaPotionsRemaining--;
    } else {
     currentP2.lastActionWasProtect = false; // Reset Protect flag even on skip
     System.out.println(currentP2.name + " has no stamina or usable potions. Turn skipped.");
    }
   }
  }
  
  return currentP2;
}


 public static void main(String[] args) throws InterruptedException {
  Scanner scanner = new Scanner(System.in);
  Random random = new Random();

  System.out.println(" ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ñ£‚óé‚ñ£‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó ");
  System.out.println(" Welcome to Pokemon Team Battle ");
  System.out.println(" ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ñ£‚óé‚ñ£‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ");

  // 1. Team Selection
  List<Pokemon> p1Team = choosePlayerTeam(scanner);
  List<String> p1Names = new ArrayList<>();
  for (Pokemon p : p1Team) {
   p1Names.add(p.originalName);
  }
  List<Pokemon> p2Team = createAITeam(p1Names, random);

  // 2. Initial Setup
  Pokemon currentP1 = p1Team.get(0);
  Pokemon currentP2 = p2Team.get(0);
  System.out.printf("%n*** P1 sends out %s! P2 sends out %s! ***%n", currentP1.name, currentP2.name);
  simulateDelay();
  
  // 3. Game Loop
while (findNextAvailablePokemon(p1Team) != null && findNextAvailablePokemon(p2Team) != null) {

    // Check for required switch (if active Pokemon fainted)
    if (currentP1.isFainted) {
        System.out.printf("%n*** %s fainted! P1 must swap! ***%n", currentP1.name);
        currentP1 = handlePlayerSwap(scanner, currentP1, p1Team);
        if (currentP1 == null) break; 
    }
    if (currentP2.isFainted) {
        System.out.printf("%n*** %s fainted! P2 must swap! ***%n", currentP2.name);
        currentP2 = handleAISwap(currentP2, p2Team, "Fainted");
        if (currentP2 == null) break;
    }

    // --- FIX START: Advance Status Before Action (P1) ---
    // Advance P1's status (Clears Protect, advances Paralyzed/Blind duration)
    advanceStatusDuration(currentP1);

    // P1 Turn: This now returns the active Pok√©mon (whether or not a swap occurred)
    Pokemon nextP1 = performPlayerTurn(scanner, currentP1, currentP2, p1Team);
    currentP1 = nextP1; 
    
    if(currentP1.health <= 0) {
        currentP1.isFainted = true;
    }
    // --- FIX END: Status Advance Moved ---

    // Check win/loss condition after P1's action (Swap or Attack)
    if (findNextAvailablePokemon(p2Team) == null) break;
    if (findNextAvailablePokemon(p1Team) == null) break;
    
    // --- FIX START: Advance Status Before Action (P2) ---
    // Advance P2's status (Clears Protect, advances Paralyzed/Blind duration)
    advanceStatusDuration(currentP2);

    // P2 Turn: The AI *always* gets its turn, whether P1 attacked or swapped.
    currentP2 = performAITurn(currentP2, currentP1, p2Team, random);
    
    // Check win/loss condition after P2's turn
    if (findNextAvailablePokemon(p1Team) == null) break;
    if (findNextAvailablePokemon(p2Team) == null) break;
    // --- FIX END: Status Advance Moved ---

    simulateDelay();
}

// 4. Game End
  System.out.println("\n======================================");
  if (findNextAvailablePokemon(p1Team) == null) {
   System.out.println("üèÜ P2 Wins! All P1 Pok√©mon have fainted! üèÜ");
  } else {
   System.out.println("üèÜ P1 Wins! All P2 Pok√©mon have fainted! üèÜ");
  }
  System.out.println("======================================");
  scanner.close();
 }
}
